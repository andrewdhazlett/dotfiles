{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":0,"width":2560,"height":1440},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/usr/local/lib/node_modules/meteorite/lib","buffers":[{"text":"var _ = require('underscore');\nvar path = require('path');\nvar wrench = require('wrench');\nvar fs = require('fs');\nvar url = require('url');\nvar spawn = require('child_process').spawn;\nvar exec = require('rolling_timeout_exec').exec;\nvar fstream = require('fstream');\n\nvar ROLLING_TIMEOUT = 15000;\n\nGitSource = function(basePath, config) {\n\n  // Setup\n  this.config = config;\n  this.sourceBasePath = path.join(Meteorite.root(), 'source');\n  this.basePath = basePath;\n  this.loaded = false;\n  this.checkoutType = this._checkoutType();\n  this.head = this._checkoutHead();\n  this.url = config.git;\n  this.sourcePath = this.sourcePath();\n  this.commit = config.commit;\n\n  if (/^http:\\/\\/github.com/.test(this.url)) {\n    // Use https to avoid 301 redirect issues with older git\n    // Issue 204 - https://github.com/oortcloud/meteorite/issues/204\n    this.url = 'https' + this.url.substring(4)\n  }\n\n};\n\nGitSource.prototype.packagePath = function() {\n  return path.join(this.basePath, this.packageNamespace(), this.commit);\n};\n\nGitSource.prototype.sourcePath = function() {\n  return path.join(this.sourceBasePath, this.packageNamespace());\n};\n\nGitSource.prototype.packageNamespace = function() {\n  var urlParts = url.parse(this.url);\n  return urlParts.path.replace(/.git$/, '').replace(/^\\//, '');\n};\n\nGitSource.prototype.fetch = function(fn, name) {\n  var self = this;\n  \n  // don't need to do anything\n  if (self.loaded)\n    return fn();\n  \n  // if the commit has been set manually, we just want to make sure _something_\n  // is checked out into our packagePath()\n  // if not, we'll check out the right commit in a sec\n  if (self.commit) {\n    self.path = self.packagePath();\n    if (fs.existsSync(self.path))\n      return fn();\n  }\n  \n  if (name === \"Meteor\") {\n    console.log();\n    console.log('Installing Meteor'.yellow);\n    console.log();\n    console.log(\"  \" + self.toString().grey);\n    console.log();\n    console.log(\"Installing smart packages\".yellow);\n    console.log();\n  } else {\n    console.log(\"✓\".green.bold + (' ' + name).bold.white);\n    console.log(\"    \" + self.toString().grey);\n  }\n\n  // Clone, pull, and checkout\n  self._clone(function() {\n    self._pull(function() {\n      self._checkout(function() {\n        self._updateSubmodules(function() {\n          self._commit(function() {\n            self.path = self.packagePath();\n            self._load(function() {\n              self.loaded = true;\n              fn();\n            });\n          });\n        });\n      });\n    });\n  });\n};\n\nGitSource.prototype._commit = function(fn) {\n  var self = this;\n  \n  GitSource.getCommitForDir(self.sourcePath, function(commit) {\n    self.commit = commit;\n    fn();\n  });\n};\n\nGitSource.prototype.toString = function() {\n  return this.checkoutType + ': ' + this.url + '#' + this.head;\n};\n\nGitSource.prototype._pull = function(fn) {\n  \n  // Just pull everything\n  spawn('git', ['pull'], {cwd: this.sourcePath}).on('exit', fn);\n};\n\nGitSource.prototype._clone = function(fn) {\n  var self = this,\n      child,\n      timedOut = false,\n      command = 'git clone --progress ' + \n                this.url + ' \"' + this.sourcePath + '\"',\n      options = { rollingTimeout: ROLLING_TIMEOUT };\n\n  if (!fs.existsSync(this.sourcePath)) {\n    child = exec(command, options, function(err, stdout, stderr) {\n      if (err) {\n        reportErrors(err, stdout, stderr, timedOut);\n        throw \"There was a problem cloning repo: \" + self.url +\n          \"\\nPlease check https://github.com/oortcloud/meteorite/blob/master/CONTRIBUTING.md#troubleshooting for potential explanations.\";\n      }\n      fn();\n    });\n    child.on('rolling-timeout', function () {\n      timedOut = true;\n    });\n  } else {\n    fn();\n  }\n};\n\nGitSource.prototype._load = function(fn) {\n  var self = this;\n\n  if (fs.existsSync(self.path))\n    return fn();\n\n  // Make sure we have a place for this to go\n\n  if (!fs.existsSync(self.path))\n    wrench.mkdirSyncRecursive(self.path);\n\n  // Copy everything over\n  var reader = fstream.Reader(self.sourcePath);\n  var writer = fstream.Writer(self.path);\n\n  // Ok fs copy is done\n  writer.on('close', function() {\n\n    // Cleanup\n    var gitDir = path.join(self.path, '.git');\n    if (!self.config.keepGitDir && fs.existsSync(gitDir))\n      wrench.rmdirSyncRecursive(gitDir);\n    fn();\n\n  });\n\n  // Start shit up!\n  reader.pipe(writer);\n};\n\nGitSource.prototype._checkout = function(fn) {\n  var self = this,\n      child,\n      timedOut = false,\n      command = 'git checkout ' + (this.commit || this.head),\n      options = { \n        rollingTimeout: ROLLING_TIMEOUT,\n        cwd: this.sourcePath\n      };\n\n  child = exec(command, options, function(err, stdout, stderr) {\n    if (err) {\n      reportErrors(err, stdout, stderr, timedOut);\n      throw \"There was a problem checking out \" +\n            self.checkoutType + \": \" + (self.commit || self.head);\n    }\n    fn();\n  });\n  child.on('rolling-timeout', function () {\n    timedOut = true;\n  })\n};\n\nGitSource.prototype._updateSubmodules = function(fn) {\n  spawn('git', ['submodule', 'update', '--init'], {cwd: this.sourcePath}).on('exit', fn);\n};\n\nGitSource.prototype._checkoutType = function() {\n  var self = this;\n  \n  // Figure out what kind of checkout we're doing\n  // i.e., is it a branch, ref, or tag\n  var types = ['branch', 'ref', 'tag'];\n  var type = _.find(types, function(type) {\n    return !_.isUndefined(self.config[type]);\n  });\n\n  // Default to branch\n  return type || 'branch';\n\n};\n\nGitSource.prototype._checkoutHead = function() {\n  \n  // Figure out what we want HEAD to point to\n  return this.config.branch || this.config.ref || this.config.tag || 'master';\n\n};\n\nGitSource.prototype.toJson = function(lock) {\n  \n  var json = {git: this.url};\n  json[this.checkoutType] = this.head;\n  if (lock)\n    json.commit = this.commit;\n  \n  return json;\n};\n\nGitSource.prototype.equals = function(otherSource) {\n  return (otherSource.url === this.url &&\n      otherSource.checkoutType === this.checkoutType &&\n      otherSource.head === this.head);\n};\n\nGitSource.prototype.conflictsWith = function(otherSource) {\n  if (otherSource instanceof GitSource)\n    // wow, they are pointing at the same place!\n    if (this.equals(otherSource))\n      return false;\n    else\n      return true;\n      \n  else if (otherSource instanceof LocalSource)\n    return true;\n}\n\nGitSource.prototype.overrides = function(otherSource) {\n  return false;\n}\n\nGitSource.getCommitForDir = function(path, fn) {\n  var self = this,\n      child,\n      timedOut = false,\n      command = 'git rev-parse HEAD',\n      options = { \n        rollingTimeout: ROLLING_TIMEOUT,\n        cwd: path \n      };\n\n  child = exec(command, options, function (err, stdout, stderr) {\n    if (err) {\n      reportErrors(err, stdout, stderr, timedOut);\n      throw \"Command exited: \" + err;\n    }\n    fn(stdout.trim());\n  });\n  child.on('rolling-timeout', function () {\n    timedOut = true;\n  });\n};\n\nmodule.exports = GitSource;\n\n\n\n\nfunction reportErrors (err, stdout, stderr, timedOut) {\n  var timedOutMsg = 'child process timed out, no activity for ' + \n                    ROLLING_TIMEOUT/1000 + ' seconds';\n\n  if (timedOut) {\n    console.error(timedOutMsg, '\\n');\n  }\n  console.error('ERROR:', err.code, err.message, '\\n');\n  console.error('STDOUT:', stdout, '\\n');\n  console.error('STDERR:', stderr, '\\n');\n}\n","markers":{"markers":{"1":{"id":1,"range":[[180,21],[180,21]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":19,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/usr/local/lib/node_modules/meteorite/lib/sources/git.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"efc72c03f3f0b57a64219acc0faa18e3019a6672","deserializer":"TextBuffer"},{"text":"var _ = require('underscore');\n\n_.mixin({\n  debugClass: function(className) {\n    _.each(global[className].prototype, function(fn, name) {\n      if (_.isFunction(fn)) {\n        global[className].prototype[name] = function() {\n          console.log(className + '#' + name);\n          return fn.apply(this, arguments)\n        };\n      }\n    });\n  }\n});\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":23},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/usr/local/lib/node_modules/meteorite/lib/debug.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"26d707fbd0f07b3d6ee43728a35006dafb361f3a","deserializer":"TextBuffer"},{"text":"var path = require('path');\nvar Project = require('../lib/project');\nvar Atmosphere = require('../lib/atmosphere');\nvar fs = require('fs');\nvar _ = require('underscore');\nvar wrench = require('wrench');\n\nvar OUR_ARGS = ['--verbose', '--repoHost', '--repoPort', '--build-dev-bundle'];\n\nMeteorite = function(args, meteorArgs) {\n  this.args = args;\n  \n  // strip our arguments out of meteorArgs, as meteor doesn't like it\n  // any more if we pass unknown things to it.\n  this.meteorArgs = _.filter(meteorArgs, function(arg) { \n    return ! _.any(OUR_ARGS, function(a) { return arg.substring(0, a.length) === a; });\n  });\n  \n  // Make directories we'll need\n  Meteorite.prepareFS();\n  \n  this.project = new Project(process.cwd(), args);\n};\n\n///////// Global meteorite commands that don't operate WRT to the current project\n\n// Meteorite command\nMeteorite.prototype.create = function(fn) {\n  var self = this;\n  \n  // in this case the project's root is _not_ process.cwd\n  var appName = this.args._[1] || this.args.example;\n  \n  if (!appName)\n    throw 'No name provided to mrt create!';\n  \n  // if you specify a path to create, you mean relative to CWD, NOT project root.\n  if (this.args.path)\n    this.args.path = path.resolve(process.cwd(), this.args.path);\n\n  self.project = new Project(path.join(process.cwd(), appName), this.args);\n  self.project.meteor.execute(this.meteorArgs, function() {\n\n    // New project needs a new smart json file\n    self.project.writeSmartJson();\n    fn();\n\n  });\n};\n\nMeteorite.prototype['create-package'] = function(fn) {\n  var self = this;\n  \n  var packageDir = this.args._[1]\n  var packageName = path.basename(packageDir);\n  \n  console.log(\"Creating package named \" + packageName + \" in \" + packageDir);\n  \n  var packageFile = packageName + '.js';\n  var testFile = packageName + '_tests.js';\n  \n  wrench.mkdirSyncRecursive(packageDir);\n  \n  // write package.js\n  fs.writeFileSync(path.join(packageDir, 'package.js'),\n    'Package.describe({\\n' +\n    '  summary: \"REPLACEME - What does this package (or the original one you\\'re wrapping) do?\"\\n' +\n    '});\\n\\n' + \n    'Package.on_use(function (api, where) {\\n' +\n    '  api.add_files(\\'' + packageFile + '\\', [\\'client\\', \\'server\\']);\\n' + \n    '});\\n\\n' +\n    'Package.on_test(function (api) {\\n' +\n    '  api.use(\\'' + packageName + '\\');\\n\\n' +\n    '  api.add_files(\\'' + testFile + '\\', [\\'client\\', \\'server\\']);\\n' +\n    '});\\n' \n  );\n  \n  // touch relevant files\n  fs.writeFileSync(path.join(packageDir, packageFile), '');\n  fs.writeFileSync(path.join(packageDir, testFile),\n    '// See https://github.com/dandv/meteor-crypto-base64/blob/master/crypto-base64_tests.js for a simple example' +\n    '// See https://www.eventedmind.com/feed/e6gJZXNQWyNP2MLsb for more on testing with Tinytest'\n  );\n  \n  // write simple smart.json\n  fs.writeFileSync(path.join(packageDir, 'smart.json'), JSON.stringify({\n    \"name\": packageName,\n    \"description\": \"REPLACEME - What does this package (or the original one you're wrapping) do?\",\n    \"homepage\": \"\",\n    \"author\": \"Your Name <your@email> (http://yoursite)\",\n    \"version\": \"0.0.1\",\n    \"git\": \"\",\n    \"packages\": {}\n  }, null, 2));\n}\n\n// XXX: this should probably track this (so further calls to mrt install\n// don't overwrite it), or else mrt install shouldn't remove symlinks by default\nMeteorite.prototype['link-package'] = function(fn) {\n  var self = this;\n  \n  var packageDir = this.args._[1];\n  var packageName = path.basename(packageDir);\n  var packagePath = 'packages/' + packageName;\n  \n  console.log(\"Linking package named \" + packageName + \" to \" + packageDir);\n  \n  var old;\n  try { old = fs.readlinkSync(packagePath); } catch (err) {}\n  \n  // already done\n  if (old && old === packageDir)\n    return;\n  \n  // pointing to the wrong spot\n  if (old)\n    fs.unlinkSync(packagePath);\n  \n  fs.symlinkSync(packageDir, packagePath);\n}\n\n/////// Package level meteorite commands\n\nMeteorite.prototype.install = function(fn) {\n  this.project.install(fn);\n};\n\nMeteorite.prototype.update = function(fn) {\n  this.project.update(fn);\n};\n\nMeteorite.prototype.publish = function(fn) {\n  Atmosphere.publish(fn);\n};\n\nMeteorite.prototype.release = function(fn) {\n  Atmosphere.release(fn);\n};\n\n// XXX: super basic right now. Just finds exact matches\nMeteorite.prototype.search = function(fn) {\n  var packageName = this.args._[1];\n  \n  Atmosphere.package(packageName, function(details) {\n    if (details) {\n      console.error((\"✓ Found package \" + packageName).green)\n      console.log(JSON.stringify(details, null, 2))\n    } else {\n      console.error((\"✘ Couldn't find package \" + packageName).red)\n    }\n    \n    fn();\n  });\n}\n\nMeteorite.prototype.uninstall = function(fn) {\n  if (this.args.system)\n    Meteorite.uninstall();\n  else\n    this.project.uninstall(fn);\n};\n\n// if the package isn't in meteor's list, add it to smart.json\nMeteorite.prototype.add = function(fn) {\n  var self = this;\n  var packageName = this.meteorArgs[1];\n  \n  var version = this.args['pkg-version'];\n  \n  // TODO: resolve the complexity of supporting more than one package being added at once\n  // for now we just spit out an error\n  if (this.args._.length > 2)\n    console.log(\"NOTE: mrt add only supports adding a single package at a time, truncating.\");\n  \n  // ensure we have the package\n  self.project.installPackage(packageName, version, function() {\n    \n    // OK. We've \"meteorite\" installed it (i.e. put it in packages/)\n    // now we just need to test if this means Meteor thinks it's installed,\n    // or if we need to `meteor add` it too.\n    \n    // XXX: at some future point when we no longer have to do this, remove.\n    self.project.isUsing(packageName, function(using) {\n      if (! using) {\n        self.project.execute(['add', packageName], fn);\n      } else {\n        fn();\n      }\n    });\n  });\n};\n\n// if the package is in smart.json, remove it from the app + smart.json\nMeteorite.prototype.remove = function(fn) {\n  var self = this;\n  var packageName = this.meteorArgs[1];\n  \n  // TODO: resolve the complexity of supporting more than one package\n  if (this.args._.length > 2)\n    console.log(\"NOTE: mrt add only supports removing a single package at a time, truncating.\");\n  \n  var uninstall = function() {\n    // remove the package from smart.json and re-run install\n    self.project.uninstallPackage(packageName, fn);\n  }\n  \n  // make sure we aren't using the package\n  self.project.isUsing(packageName, function(using) {\n    if (using) {\n      self.project.execute(['remove', packageName], uninstall);\n    } else {\n      uninstall();\n    }\n  });\n}\n\n// Meteor commands, will get run either by the project install or the default meteor\n// FIXME -- 'update'?\n// TODO -- treat list specially\n_.each([\n  'run',\n  'help',\n  'list',\n  'bundle',\n  'mongo',\n  'deploy',\n  'logs',\n  'reset',\n  'test-packages'\n], function(command) {\n  Meteorite.prototype[command] = function(fn) {\n    this.project.execute(this.meteorArgs, fn);\n  };\n});\n\n// Class methods\n\nMeteorite.root = function() {\n  var homeDir = process.env.HOME;\n  return path.join(homeDir, '.meteorite');\n};\n\n// Creates the path to ~/.meteorite\nMeteorite.prepareFS = function() {\n  var root = Meteorite.root();\n  if (!fs.existsSync(root))\n    fs.mkdirSync(root);\n};\n\n// Uninstall everything from ~/.meteorite\nMeteorite.uninstall = function() {\n  // TODO prompt for confirmation\n  console.log('Deleting ~/.meteorite. Note that previously installed projects will no longer work');\n  \n  var root = Meteorite.root();\n  if (fs.existsSync(root)) \n    wrench.rmdirSyncRecursive(root);    \n};\n\nmodule.exports = Meteorite;\n\n// var _debug = require('./debug');\n// _.debugClass('Meteorite');\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":27},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/usr/local/lib/node_modules/meteorite/lib/meteorite.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"812f06d3dbeaa65089758862fec6b543ea13cfe0","deserializer":"TextBuffer"},{"text":"var path = require('path');\nvar fs = require('fs');\nvar _ = require('underscore');\nvar Dependencies = require('./dependencies/dependencies');\nvar Config = require('./config');\nvar Meteor = require('./meteor');\nvar Command = require('./command');\nvar wrench = require('wrench');\nvar exec = require('child_process').exec;\n\n// The project is the current directory's personal version of meteor,\n// complete with its own set of packages.\n// it installs into ./meteor/meteorite\n\nProject = function(root, meteorArgs) {\n  \n  // Figure out all the paths we'll need to know\n  this.root = root;\n  this.meteorArgs = meteorArgs;\n  this.smartJsonPath = path.join(this.root, 'smart.json');\n  this.smartLockPath = path.join(this.root, 'smart.lock');\n  this.packagesRoot = path.join(this.root, 'packages');\n  \n  // set a base meteor if it's specified in the args (or a default one if not)\n  this.meteor = new Meteor(meteorArgs);\n};\n\n// read the config from smart.lock if it exists\nProject.prototype.initFromLock = function() {\n  var self = this;\n  \n  if (fs.existsSync(this.smartLockPath)) {\n    var data = fs.readFileSync(this.smartLockPath).toString();\n    var lockData = JSON.parse(data);\n    \n    // embed the root path in all this data\n    lockData.meteor.root = self.root;\n    _.each(lockData.dependencies.basePackages, function(pkg) {\n      pkg.root = self.root;\n    });\n    _.each(lockData.dependencies.packages, function(pkg) {\n      pkg.root = self.root;\n    });\n    \n    this.meteor = new Meteor(lockData.meteor);\n    this.dependencies = Dependencies.newFromLockJson(lockData.dependencies);\n  }\n};\n\n// have a look in smart.json, see if it's different to what we have from smart.lock\nProject.prototype.checkSmartJson = function(forceUpdate) {\n  \n  // this is the config specified in smart.json\n  var config = new Config(this.root);\n  \n  var newMeteor = new Meteor(config.meteor);\n  // when running in the context of a package, we are the only required package\n  if (config.name) {\n    var specifier = {};\n    specifier[config.name] = {path: \".\"};\n    var newDeps = new Dependencies(specifier);\n  } else {\n    var newDeps = new Dependencies(config.packages);\n  }\n  \n  if (forceUpdate || !this.meteor.equals(newMeteor) || !this.dependencies || !this.dependencies.equalBase(newDeps)) {\n    \n    if (!forceUpdate && this.dependencies)\n      console.log('smart.json changed.. installing from smart.json');\n      \n    this.lockChanged = true;\n    this.meteor = newMeteor;\n    this.dependencies = newDeps;\n  }\n};\n\n// FIXME - this doesn't actually fetch the packages.\n// we only fetch them when we are about to install them, or we need to \n// take a look inside them. I think this is reasonable.\nProject.prototype.fetch = function(fn, forceUpdate) {\n  var self = this;\n  \n  // prepare dependencies and meteor\n  self.initFromLock();\n  self.checkSmartJson(forceUpdate);\n  \n  // Ensure the right version of meteor has been fetched\n  var buildDevBundle = !! self.meteorArgs['build-dev-bundle'];\n  self.meteor.prepare(buildDevBundle, function() {\n    \n    // resolving dependencies fetches them. We need to check otherwise\n    if (!self.dependencies.resolved()) {\n\n      console.verbose('Resolving dependency tree');\n\n      self.dependencies.resolve(self.meteorArgs.force, function(err, conflicts) {\n        \n        _.each(conflicts, function(conflict, name) {\n          console.log(('Problem installing ' + name.bold).red);\n          console.log((\"  ✘ \" + conflict).red);\n        });\n        \n        if (err) {\n          console.log(err.message.red);\n          process.exit(1);\n        }\n          \n        fn();\n      });\n    } else {\n      fn();\n    }\n  });\n};\n\nProject.prototype.uninstall = function() {\n  var self = this;\n  \n  // for now, remove anything in packages/ that is a symlink  \n  if (fs.existsSync(this.packagesRoot)) {\n    var dirs = fs.readdirSync(this.packagesRoot);\n    \n    _.each(dirs, function(dir) {\n      var dirPath = path.join(self.packagesRoot, dir);\n      \n      if (fs.lstatSync(dirPath).isSymbolicLink())\n        fs.unlink(dirPath)\n    });\n  }\n};\n\n// either install from smart.lock or prepare smart.lock and do so\nProject.prototype.install = function(fn, forceUpdate) {\n  var self = this;\n  \n  self._optimizeFS();\n  \n  // Fetch everything the project needs\n  self.fetch(function() {\n    \n    // ensure that the installRoot exists\n    if (! self.dependencies.isEmpty())\n      wrench.mkdirSyncRecursive(self.packagesRoot);\n      \n    // Link each package into installRoot\n    self.dependencies.installInto(self, function(packagesInstalled) {\n      console.log();\n      console.log('Done installing smart packages'.bold);\n      \n      // install the smart.lock file\n      if (fs.existsSync(self.smartJsonPath) && (self.lockChanged || !fs.existsSync(self.smartLockPath)))\n        self.writeLockFile();\n      \n      fn();\n    });\n  }, forceUpdate);\n};\n\n// if there's no dependencies we don't have to install\nProject.prototype.needsToInstall = function() {\n  return !this.dependencies.isEmpty();\n}\n\n// prepare a new smart.lock, then install\nProject.prototype.update = function(fn) {\n  \n  this.install(fn, true);\n};\n\nProject.prototype.execute = function(args, fn) {\n  var self = this;\n\n  if (self.meteorArgs.version) \n    console.suppress();\n\n  console.log();\n  console.log(\"Stand back while Meteorite does its thing\".bold);\n  \n  // TODO -- what do we do here if not installed? I'm not sure we just go ahead\n  //   and install, we should probably abort and tell them\n  self.install(function() {\n\n    console.log();\n    console.log(\"Ok, everything's ready. Here comes Meteor!\".green);\n    console.log();\n\n    if (self.meteorArgs.version) \n      console.unsuppress();\n    \n    self.meteor.execute(args, self.packagesRoot, fn);\n  });\n};\n\n// assumes that we are installed.\nProject.prototype.isUsing = function(packageName, fn) {\n  var self = this;\n  \n  self.install(function() {\n    return self.meteor.isUsing(packageName, fn);\n  });\n}\n\n// ensure a named package is installed\n//\n// NOTE: Right now, if the package is already available (included in meteor, already in smart.json)\n// we ignore the version, and just stick with what we have\n//\n// TODO: In the future a version # would override anything in meteor + rewrite smart.json\n// but right now it's TBH to overwrite meteor's packages.\nProject.prototype.installPackage = function(pkgName, version, fn) {\n  var self = this;\n  \n  // first ensure we are fetched, so we know _all_ the packages that are available\n  self.fetch(function() {\n    \n    self.hasPackage(pkgName, function(check) {\n      // if we have the package already\n      if (check)\n        return fn();\n        \n      // better check that the package exists on atmosphere\n      Atmosphere.package(pkgName, function(atmosphere_defn) {\n    \n        if (!atmosphere_defn)\n          throw(\"Package named \" + pkgName + \" doesn't exist in your meteor installation, smart.json, or on atmosphere\");\n    \n        // ok, it's not installed. So we need to add it (permanently) to the smart.json\n        // and clear our dependencies\n        var smartJson = self.readSmartJson();\n        var defn = {}\n        if (version)\n          defn.version = version;\n        smartJson.packages = smartJson.packages || {};\n        smartJson.packages[pkgName] = defn;\n        self.writeSmartJson(smartJson);\n    \n        // maybe a hack to read it back out from disk, but not a big deal I don't think\n        self.checkSmartJson(true);\n    \n        fn();\n      });\n    });\n  });\n}\n\n// remove a package that is listed in smart.json (if it is indeed listed there)\nProject.prototype.uninstallPackage = function(pkgName, fn) {\n  var self = this;\n  \n  // we need to be fetched so we have all the information\n  // self.fetch(function() {\n  \n  var pkg = self.dependencies.basePackages[pkgName];\n  if (pkg) {\n    // remove that bad boy from smart.json and reset our dependencies\n    var smartJson = self.readSmartJson();\n    delete smartJson.packages[pkgName];\n    self.writeSmartJson(smartJson);\n    \n    // maybe a hack to read it back out from disk, but not a big deal I don't think\n    self.checkSmartJson(true);\n    \n    // now bring everything in line with smart.json\n    self.install(function() {\n      // finally remove package from packages/\n      pkg.removeFrom(self, fn);\n    });\n  } else {\n    fn();\n  }\n}\n\n\n\n// Is the package part of the meteor install, or is it a dependency?\n//\n// NOTE: assumes we have fetched. FIXME: figure out a better / systematic way\n// to write code that has this sort of assumption\nProject.prototype.hasPackage = function(pkgName, fn) {\n  if (this.dependencies.packages[pkgName]) {\n    return fn(true);\n  }\n  \n  this.meteor.hasPackage(pkgName, fn)\n};\n\n// very simple version of what config does\nProject.prototype.readSmartJson = function() {\n  \n  try {\n    var rawConfig = fs.readFileSync(path.join(this.root, 'smart.json')).toString();\n    return JSON.parse(rawConfig);\n    \n  } catch (err) {\n    return {};\n  }\n};\n\nProject.prototype.smartJson = function() {\n  var data = {};\n  \n  if (!this.meteor.defaultMeteor)\n    data.meteor = this.meteor.toJson();\n  \n  if (this.dependencies)\n    data.packages = this.dependencies.toJson().basePackages;\n  else\n    data.packages = {};\n  \n  return data;\n};\n\n\nProject.prototype.writeSmartJson = function(json) {\n  json = json || this.smartJson();\n  \n  // Make a nicely formated default json string\n  var smartJsonString = JSON.stringify(json, null, 2) + \"\\n\";\n  \n  // Write to disk\n  if (fs.existsSync(this.root))\n    fs.writeFileSync(this.smartJsonPath, smartJsonString);\n};\n\nProject.prototype.lockJson = function() {\n  \n  return {\n    meteor: this.meteor.toJson(true),\n    dependencies: this.dependencies.toJson(true)\n  };\n};\n\n// write out into smart.lock\nProject.prototype.writeLockFile = function() {\n  \n  var smartJsonString = JSON.stringify(this.lockJson(), null, 2) + \"\\n\";\n  fs.writeFileSync(this.smartLockPath, smartJsonString);\n};\n\nProject.prototype._optimizeFS = function() {\n  var self = this;\n\n  var deletable = [];\n  \n  // remove old .meteor/meteorite directory\n  var oldInstallRoot = path.join(this.root, '.meteor', 'meteorite')\n  if (fs.existsSync(oldInstallRoot)) {\n    deletable.push(oldInstallRoot);\n  }\n  \n  if (deletable.length > 0)\n    console.log(\"Yay! We're optimizing your installation!\".yellow.bold);\n  \n  _.each(deletable, function(filePath) {\n    console.log(\"  ✘ \".red + (\"Deleting \" + filePath).grey);\n\n    if (fs.lstatSync(filePath).isDirectory())\n      wrench.rmdirSyncRecursive(filePath);\n    else\n      fs.unlink(filePath);\n  });\n};\n\nmodule.exports = Project;\n\n// var _debug = require('./debug');\n// _.debugClass('Project');\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":31},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/usr/local/lib/node_modules/meteorite/lib/project.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e2a8d00b42319ed1d1d3ca96967ecde653995afc","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":19,"softTabs":true,"displayBuffer":{"id":20,"softWrap":true,"editorWidthInChars":175,"scrollTop":4136,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/usr/local/lib/node_modules/meteorite/lib/sources/git.js","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":23,"softTabs":true,"displayBuffer":{"id":24,"softWrap":true,"editorWidthInChars":176,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/usr/local/lib/node_modules/meteorite/lib/debug.js","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":27,"softTabs":true,"displayBuffer":{"id":28,"softWrap":true,"editorWidthInChars":175,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/usr/local/lib/node_modules/meteorite/lib/meteorite.js","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":31,"softTabs":true,"displayBuffer":{"id":32,"softWrap":true,"editorWidthInChars":175,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/usr/local/lib/node_modules/meteorite/lib/project.js","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/usr/local/lib/node_modules/meteorite/lib/project.js","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":true,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/usr/local/lib/node_modules/meteorite/lib/sources/git.js":1404249232285,"/usr/local/lib/node_modules/meteorite/lib/debug.js":1404249286162,"/usr/local/lib/node_modules/meteorite/lib/meteorite.js":1404249294056,"/usr/local/lib/node_modules/meteorite/lib/project.js":1404249709204},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":2950308},"tree-view":{"directoryExpansionStates":{"sources":{}},"selectedPath":"/usr/local/lib/node_modules/meteorite/lib/project.js","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}